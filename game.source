// Definitions
inline left = 37;
inline up = 38;
inline right = 39;
inline down = 40;
inline space = 32;

inline dt = state[0]; // filled by the engine
inline time = state[8];

inline playerX = state[1];
inline playerY = state[2];
inline score = state[5];
inline lives = state[6];

time += dt;

playerX += (get_key(right) - get_key(left))*dt*0.8;
playerY += (get_key(up) - get_key(down))*dt*0.8;

playerX = clamp(playerX, -1, 1);
playerY = clamp(playerY, -0.5, 0.5);

// Animation after losing life
state[4] = clamp(state[4] - dt, 0., 1.);

inline enemyDataSize = 4;

// spawning
if ((time >= 0) * (time < 0.5)) { // reset
    enemies[0] = 0;
    playerX = 0;
    playerY = -0.3;
    score = 0;
    lives = 0;
    coolDown = 0;
    level = 0;
} else if (time < 1) {
    lives = 3;

    // init enemies data
    for (i = 0; i < 20; i += 1) {
        enemies[i*enemyDataSize + 1] = 0; // kind
        enemies[i*enemyDataSize + 2] = i; // seed
        enemies[i*enemyDataSize + 3] = 0;
        enemies[i*enemyDataSize + 4] = 10;
    }
    // set enemy kinds
    index = 3*enemyDataSize + 1;
    enemies[index] = 1;
    index += enemyDataSize;
    enemies[index] = 1;

    index += enemyDataSize;
    enemies[index] = 2;

    index += enemyDataSize;
    enemies[index] = 3;
}

// Add enemies over time
t = time;
enemies[0] = 2;
while (t > 0) {
    t -= 7;
    enemies[0] += 1;
}

// Enemy movement
for (i = 0; i < enemies[0]; i += 1) {
    kind = enemies[i*enemyDataSize + 1];
    mixer = 0;
    if (kind == 0) {
        tx = sin(time + i) * 0.8; // px
        ty = i * 0.1 + sin(time + 1.5) * 0.5 - 0.1;
    }
    if (kind == 1) {
        tx = playerX;
        ty = playerY;
        mixer = 0;
    }
    if (kind == 2) {
        tx = sin(time);
        ty = playerY;
        mixer = 0;
    }
    if (kind == 3) {
        tx = playerX;
        ty = sin(time);
        mixer = 0;
    }

    // Two interpolation modes
    if (mixer == 1) {
        enemies[i*enemyDataSize + 3] += clamp(tx - enemies[i*enemyDataSize + 3], -0.01, 0.01); // px
        enemies[i*enemyDataSize + 4] += clamp(ty - enemies[i*enemyDataSize + 4], -0.01, 0.01); // px
    } else {
        // non-linear speed, slowing down when reaching target
        enemies[i*enemyDataSize + 3] = mix(enemies[i*enemyDataSize + 3], tx, 0.04); // px
        enemies[i*enemyDataSize + 4] = mix(enemies[i*enemyDataSize + 4], ty, 0.04); // py
    }
}

// collision with enemies
for (j = 0; j < enemies[0]; j += 1) {
    dx = enemies[j*enemyDataSize + 3] - playerX;
    dy = enemies[j*enemyDataSize + 4] - playerY;
    if (dx * dx + dy * dy < 0.07 * 0.07) {
        enemies[j*enemyDataSize + 3] = sin(j);
        enemies[j*enemyDataSize + 4] = 10; // move out of screen
        state[4] = 1.;
        lives -= 1;
    }
}

// Move missiles
for (i = missiles[0] - 1; i >= 0; i -= 1) {
    missiles[i*2 + 2] += 1 * dt;

    // collisions with enemies
    for (j = 0; j < enemies[0]; j += 1) {
        dx = enemies[j*enemyDataSize + 3] - missiles[i*2 + 1];
        dy = enemies[j*enemyDataSize + 4] - missiles[i*2 + 2];
        dist2 = dx * dx + dy * dy;
        if (dist2 < 0.05 * 0.05) {
            enemies[j*enemyDataSize + 4] = -10; // move out of screen
            score += 1;

            nbexplo = explosions[0];
            explosions[nbexplo*3 + 1] = missiles[i*2 + 1];
            explosions[nbexplo*3 + 2] = missiles[i*2 + 2];
            explosions[nbexplo*3 + 3] = 1;
            explosions[0] += 1;

            missiles[i*2 + 2] = 10; // move out of screen
        }
    }

    // remove missiles outside the screen
    if (missiles[i*2 + 2] > 0.5) {
        // O(1) removal: swap element with the last one in the array
        missiles[i*2 + 1] = missiles[(missiles[0] - 1)*2 + 1];
        missiles[i*2 + 2] = missiles[(missiles[0] - 1)*2 + 2];
        missiles[0] -= 1;
    }
}

// update explosions
for (i = explosions[0] - 1; i >= 0; i -= 1) {
    explosions[i*3 + 3] -= dt;
    if (explosions[i*3 + 3] <= 0) {
        explosions[i*3 + 1] = explosions[(explosions[0] - 1)*2 + 1];
        explosions[i*3 + 2] = explosions[(explosions[0] - 1)*2 + 2];
        explosions[0] -= 1;
    }
}


if (get_key(space)) {
    if (time - coolDown > 0.15) {
		coolDown = time;
        // Fire, create missile
		missiles[missiles[0]*2 + 1] = playerX;
		missiles[missiles[0]*2 + 2] = playerY;
		missiles[0] += 1; // number of missiles
	}
}

// death
if ((time > 2) * (lives <= 0)) {
    time = -2.0;
}
